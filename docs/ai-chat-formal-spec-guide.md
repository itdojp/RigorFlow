# AIチャット駆動形式的仕様開発実践ガイド

## はじめに

本ガイドは、生成AI（Claude等）との対話を通じて、プロジェクトに最適な形式手法を選択・適用し、TDDで実装を進めるための実践的な指針です。すべてのプロジェクトで形式手法を使う必要はなく、AIが診断して必要な手法を提案します。

## 第0部：プロジェクト診断

### 0.1 形式手法の要否判定

#### AIへの診断依頼

```markdown
## プロジェクト診断依頼
「以下のプロジェクトに形式手法が必要か診断してください：

プロジェクト概要：[記述]
リスクレベル：[低/中/高]
複雑度：[単純/通常/複雑]
重要な特性：[並行性/暗号/金銭/人命]

診断結果として以下を提示：
1. 形式手法の要否
2. 必要な場合、どのレベルか（Level 0-4）
3. 推奨する実装言語
4. 段階的導入計画」
```

#### 診断結果による分岐

**形式手法不要の場合**：
- 通常の設計・開発プロセスへ
- BDDとTDDで品質確保
- 必要に応じて後から追加

**形式手法必要の場合**：
- 必要最小限から開始
- リスクの高い部分のみ適用
- 段階的に拡大

## 第1部：要求分析と仕様生成（必要に応じて）

### 1.1 要求仕様の作成（Level 0-1）

#### 基本的な要求記述（全プロジェクト）

```markdown
## 要求の明確化
「以下のシステムについて要求を整理してください：

システム概要：[概要を記述]
主要機能：[箇条書きで記述]

出力形式：
- Level 0: 自然言語での明確な要求記述
- Level 1追加時: BDDシナリオ形式も作成」
```

#### BDD仕様（Level 1選択時）

```gherkin
Feature: 機能名
  Scenario: シナリオ名
    Given 前提条件
    When アクション
    Then 期待結果
```

### 1.2 形式的仕様の選択的適用

#### どの部分に形式手法を適用するか

```markdown
「このシステムで形式手法を適用すべき部分を特定してください：

システム機能一覧：[リスト]

分析観点：
- 並行性リスク → Level 3 (TLA+等)
- 計算の正確性 → Level 4 (Dafny等)
- データ整合性 → Level 2 (型システム)
- 通常処理 → Level 0-1で十分

推奨を部分ごとに提示してください」
```

### 1.3 言語非依存の仕様作成

#### Level 3: モデル検査が必要な場合

```markdown
「並行処理の問題があるため、モデル検査を行います：

対象：[セッション管理、メッセージ順序等]
使用ツール：TLA+、Alloy、その他から選択

仕様に含める要素：
- 並行動作する要素
- 同期・通信メカニズム
- タイミング制約
- 不変条件

実装言語は後で決定します」
```

#### Level 4: 証明が必要な場合

```markdown
「暗号処理の正確性を証明する必要があります：

対象：[暗号関数、セキュリティプロトコル]
使用ツール：Dafny、Coq、F*から選択

仕様に含める要素：
- 事前条件・事後条件
- 不変条件
- 数学的性質

実装言語は証明可能性を考慮して選択」
```

#### 基本構造テンプレート

```markdown
「以下の要素を含むTLA+仕様を作成してください：

1. 定数（CONSTANTS）
   - プレイヤー集合
   - タイムアウト値
   - 手の種類

2. 変数（VARIABLES）  
   - 各プレイヤーの状態
   - ゲームセッション状態
   - メッセージキュー

3. 初期状態（Init）
   - すべての変数の初期値

4. アクション
   - プレイヤー参加
   - 手の選択とコミット
   - 結果公開
   - タイムアウト処理

5. 不変条件
   - 型不変条件（TypeInvariant）
   - 安全性条件（SafetyInvariant）

6. 活性条件
   - 最終的に勝敗が決まる
   - デッドロックしない」
```

#### TLA+仕様の品質確認

**AIへの検証依頼**：

```markdown
「作成したTLA+仕様を以下の観点で検証してください：

構文チェック：
- MODULE宣言があるか
- EXTENDS句が適切か
- 変数宣言の形式は正しいか

意味チェック：
- Init述語で全変数を初期化しているか
- Next述語にすべてのアクションが含まれているか
- 不変条件が意味のあるものか

完全性チェック：
- BDD仕様のすべてのシナリオがカバーされているか
- エラーケースが考慮されているか
- 並行実行時の問題が考慮されているか」
```

### 1.4 Dafny仕様の作成

#### 契約設計テンプレート

```markdown
「以下のDafny仕様を作成してください：

1. データ型定義
   - Move型（グー、チョキ、パー）
   - GameResult型（勝ち、負け、引き分け）
   - Commitment型（ハッシュ値）
   - Proof型（ゼロ知識証明）

2. 純粋関数の契約
   function CreateCommitment(move: Move, nonce: nat): Commitment
     ensures |result| == 64  // ハッシュ長

   function JudgeGame(move1: Move, move2: Move): GameResult
     ensures move1 == move2 ==> result == Draw
     ensures (move1 == Rock && move2 == Scissors) ==> result == Win

3. メソッドの契約
   method VerifyProof(proof: Proof, commitment: Commitment) 
     returns (valid: bool)
     ensures valid ==> ProofMatchesCommitment(proof, commitment)

4. 不変条件
   - データ構造の整合性
   - 暗号学的性質」
```

#### Dafny仕様の検証

```markdown
「Dafny仕様を以下の観点で確認してください：

契約の完全性：
- すべての関数に ensures句があるか
- 必要な requires句が定義されているか
- 副作用のあるメソッドに modifies句があるか

契約の健全性：
- 事前条件が強すぎないか
- 事後条件が実現可能か
- 不変条件が保持可能か

実装可能性：
- Rustで実装可能な契約か
- パフォーマンス要件を満たせるか」
```

## 第2部：仕様検証と改善

### 2.1 仕様間の整合性確認

#### 整合性チェックリスト

```markdown
「TLA+仕様とDafny仕様の整合性を確認してください：

状態対応：
□ TLA+の各変数に対応するDafnyの型があるか
□ 状態遷移が両仕様で一致しているか

操作対応：
□ TLA+の各アクションにDafnyの関数/メソッドが対応するか
□ 引数と戻り値の型が整合しているか

エラー処理：
□ エラーケースが両仕様で同じように扱われているか
□ タイムアウトなど時間的要素の扱いが明確か

以下の形式で不整合を報告してください：
- 不整合箇所：[具体的な場所]
- 問題の内容：[詳細]
- 修正案：[提案]」
```

### 2.2 要求カバレッジ確認

```markdown
「BDD要求仕様と形式的仕様のカバレッジを分析してください：

## チェック項目
1. 各BDDシナリオが仕様のどこでカバーされているか
2. カバーされていない要求はあるか
3. 仕様にあるが要求にない機能はあるか

## 報告形式
シナリオ名：[シナリオ]
- TLA+での対応：[対応箇所]
- Dafnyでの対応：[対応箇所]
- カバレッジ：[完全/部分的/なし]」
```

### 2.3 実装可能性の確認

```markdown
「形式的仕様の実装可能性を評価してください：

技術的実現性：
- 選択した技術スタックで実装可能か
- パフォーマンス要件を満たせるか
- 必要なライブラリは利用可能か

複雑度評価：
- 実装の推定工数
- 技術的難易度
- リスク要因

代替案の提案：
- より簡単な実装方法はあるか
- 仕様の簡略化は可能か」
```

## 第3部：テスト駆動開発

### 3.1 テスト生成戦略

#### 仕様からのテスト導出

```markdown
「形式的仕様から以下のテストを生成してください：

1. Dafny契約からのユニットテスト
   - 正常系：契約を満たす入力
   - 境界値：契約の境界条件
   - 異常系：契約違反のケース

2. TLA+不変条件からのプロパティテスト
   - 状態不変条件の保持
   - 安全性性質の検証
   - 活性性質の確認

3. BDDシナリオからの受け入れテスト
   - Given-When-Thenの直接変換
   - エンドツーエンドフロー

各テストに以下を含めてください：
- テスト名（意図が分かる名前）
- テストの目的
- 期待する結果」
```

### 3.2 TDDサイクル実践

#### サイクル1：最初のテスト

```markdown
「最初のテストケースを作成してください：

対象機能：[実装する機能]
テストの種類：[ユニット/統合]
言語：[Rust/Elixir]

以下の形式で：
1. テストコード（失敗することが前提）
2. テストの意図の説明
3. 最小実装の方針」
```

#### サイクル2：実装

```markdown
「このテストを通す最小限の実装を提供してください：

テスト：[先ほどのテスト]

要件：
- テストを通すことだけを考える
- 過度な設計をしない
- 後でリファクタリングする前提で」
```

#### サイクル3：リファクタリング

```markdown
「実装をリファクタリングしてください：

現在の実装：[コード]

改善点：
- コードの重複除去
- 可読性の向上
- パフォーマンスの改善
- 設計パターンの適用

ただしテストは変更しない」
```

#### サイクル4：次のテスト

```markdown
「次に書くべきテストを提案してください：

実装済み機能：[リスト]
未実装機能：[リスト]

優先順位の基準：
- リスクの高い機能
- 他機能への依存
- ビジネス価値」
```

### 3.3 テストの品質確認

```markdown
「作成したテストスイートを評価してください：

カバレッジ：
- 行カバレッジ
- 分岐カバレッジ
- 仕様カバレッジ

品質指標：
- テストの独立性
- 実行速度
- 保守性
- 意図の明確性

改善提案：
- 不足しているテストケース
- 冗長なテスト
- テスト構造の改善点」
```

## 第4部：統合とシステムテスト

### 4.1 コンポーネント統合

#### Elixir-Rust境界テスト

```markdown
「境界でのインテグレーションテストを設計してください：

境界インターフェース：
- 関数名：[Elixirから呼ぶRust関数]
- 入力型：[データ形式]
- 出力型：[戻り値形式]

テストケース：
1. 正常なデータ受け渡し
2. エラーの伝播
3. 型変換の正確性
4. パフォーマンス（レイテンシ）
5. 並行呼び出し時の動作」
```

### 4.2 エンドツーエンドテスト

```markdown
「BDDシナリオに基づくE2Eテストを作成してください：

シナリオ：[BDDシナリオ名]

テスト環境：
- 必要なサービス
- テストデータ
- モック/スタブ

実行ステップ：
1. 環境準備
2. シナリオ実行
3. 結果検証
4. クリーンアップ

期待結果：
- 機能面の確認項目
- 非機能面の確認項目」
```

### 4.3 システム品質の確認

```markdown
「システム全体の品質を評価してください：

機能要件の充足：
□ すべてのBDDシナリオが動作するか
□ エラーケースが適切に処理されるか

非機能要件の充足：
□ 応答時間は要件を満たすか
□ 同時接続数は要件を満たすか
□ セキュリティ要件を満たすか

改善の余地：
- パフォーマンスボトルネック
- エラーハンドリングの改善点
- ユーザビリティの問題」
```

## 第5部：実践的な進め方

### 5.1 フェーズごとの時間配分（標準的な1機能の場合）

| フェーズ | 作業内容 | 所要時間 | 成果物 |
|---------|---------|----------|--------|
| **要求定義** | BDD仕様作成 | 30-60分 | BDDシナリオ |
| **ドメイン分析** | 技術分割判断 | 20-30分 | 分割設計 |
| **仕様生成** | TLA+/Dafny作成 | 60-90分 | 形式的仕様 |
| **仕様検証** | 整合性・完全性確認 | 30-45分 | 検証済み仕様 |
| **テスト生成** | 各種テスト作成 | 45-60分 | テストコード |
| **TDD実装** | 実装とリファクタリング | 2-4時間 | 実装コード |
| **統合テスト** | E2E確認 | 30-45分 | 動作確認済みシステム |

### 5.2 AIとの効果的な対話のコツ

#### 良い質問の仕方

**具体的で文脈を含む**：
```
✅ 良い例：
「じゃんけんの勝敗判定関数について、Dafny契約から
Rustのユニットテストを生成してください。
特に引き分けのケースを網羅的にテストしたいです。」

❌ 悪い例：
「テストを書いて」
```

**段階的に進める**：
```
✅ 良い例：
1. 「まず最も簡単なケースのテストを1つ作成」
2. 「次に境界値のテストを追加」
3. 「最後にエラーケースを追加」

❌ 悪い例：
「全部のテストを一度に生成」
```

**フィードバックを含める**：
```
✅ 良い例：
「生成されたTLA+仕様でタイムアウト処理が
不明確です。より詳細に定義してください。」

❌ 悪い例：
「仕様が違う」
```

### 5.3 トラブルシューティング

#### よくある問題と対処法

| 問題 | 症状 | AIへの質問例 |
|------|------|-------------|
| **仕様の不整合** | TLA+とDafnyで状態が異なる | 「両仕様の状態表現を統一する方法を提案してください」 |
| **テスト失敗** | 期待と異なる結果 | 「このテスト失敗の原因を分析してください：[エラー内容]」 |
| **実装困難** | 仕様が複雑すぎる | 「この仕様をより簡単に実装する方法はありますか」 |
| **パフォーマンス** | 処理が遅い | 「この処理のボトルネックを特定して改善案を提示してください」 |

### 5.4 品質チェックリスト

#### 各フェーズの完了条件

```markdown
□ BDD仕様
  □ すべての主要機能がシナリオ化されている
  □ 受け入れ条件が明確
  □ 具体的で測定可能

□ 形式的仕様
  □ 構文エラーがない
  □ BDD要求をカバーしている
  □ 実装可能な内容

□ テスト
  □ カバレッジ90%以上
  □ 全テストが実行可能
  □ 意図が明確

□ 実装
  □ 全テストがパス
  □ リファクタリング完了
  □ コードレビュー済み

□ 統合
  □ E2Eテスト成功
  □ 非機能要件充足
  □ デプロイ可能
```

## 付録A：言語別テンプレート

### Rust（Dafny仕様の実装）

```rust
// ユニットテストのテンプレート
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_機能名_正常系() {
        // Arrange
        let input = 準備();
        
        // Act
        let result = 対象関数(input);
        
        // Assert
        assert_eq!(result, 期待値);
    }

    #[test]
    #[should_panic(expected = "エラーメッセージ")]
    fn test_機能名_異常系() {
        // 異常系のテスト
    }
}
```

### Elixir（TLA+仕様の実装）

```elixir
# プロパティテストのテンプレート
defmodule GameTest do
  use ExUnit.Case
  use PropCheck

  property "不変条件の保持" do
    forall state <- game_state_generator() do
      # プロパティの検証
      valid_state?(state)
    end
  end

  test "状態遷移の正確性" do
    # Given
    initial_state = %GameState{}
    
    # When  
    new_state = GameSession.apply_action(initial_state, action)
    
    # Then
    assert valid_transition?(initial_state, new_state)
  end
end
```

## 付録B：プロジェクト規模別の調整

### 小規模（1週間程度）
- BDD：主要3-5シナリオ
- 形式的仕様：コア機能のみ
- テスト：ユニットテスト中心
- 簡略化OK

### 中規模（1ヶ月程度）
- BDD：全機能カバー
- 形式的仕様：TLA+とDafny両方
- テスト：全レベル実施
- 品質基準厳守

### 大規模（3ヶ月以上）
- BDD：詳細なシナリオ
- 形式的仕様：完全な仕様
- テスト：包括的テスト
- 性能・セキュリティ重視

## まとめ

このガイドに従い、AIとの対話を通じて：

1. **要求を明確化**（BDD）
2. **仕様を形式化**（TLA+/Dafny）
3. **テストを生成**（仕様から導出）
4. **TDDで実装**（段階的に）
5. **統合して検証**（E2E）

すべてのステップでAIを活用し、スクリプト作成なしで高品質なシステムを構築できます。

### 成功のポイント

- **段階的に進める**：一度に多くを求めない
- **具体的に質問**：文脈と意図を明確に
- **フィードバック重視**：結果を確認して改善
- **品質基準の維持**：チェックリストの活用

このアプローチにより、形式的な正しさと実用性を両立したシステムを効率的に開発できます。

---

**作成日**: 2025年8月8日  
**バージョン**: 1.0